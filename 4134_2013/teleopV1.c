#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S3,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     RightDrive,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     LeftDrive,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     Flag,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     BlockArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     LiftArm,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S2_C3_1,    Clamp,                tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "libs/teleoputils.h"
#include "libs/constants.h"

bool lastButtons[37];
int armOwner=0;  //1: Rem1POV, 0: Rem2J2 ; Changed dynamically as needed
bool wiggle=false;
bool slowMode=false;
int driveSpeedLeft;
int driveSpeedRight;

void performButtonAction(short buttonID, bool pressed) {
	switch(buttonID) {
	case BUTTON_ID(1, 6): 	if(pressed) {motor[Flag] = 100;} else {motor[Flag] = 0;} break;		//Flag
	case BUTTON_ID(1, 8): 	if(pressed) {motor[Flag] = -100;} else {motor[Flag] = 0;} break;	//Flag
	case POV_1_LEFT: 		if(pressed) {servo[Clamp] = CLAMP_RELEASE;} else {} break;			//Release Clamp
	case POV_1_RIGHT: 		if(pressed) {servo[Clamp] = CLAMP_HOLD;} else {} break;				//Hold Clamp
	case BUTTON_ID(2, 5): 	if(pressed) {servo[Clamp] = CLAMP_RELEASE;} else {} break;			//Release Clamp
	case BUTTON_ID(2, 7): 	if(pressed) {servo[Clamp] = CLAMP_HOLD;} else {} break;				//Hold Clamp
	case POV_1_UP:	 		if(pressed) {armOwner=1;} else {armOwner=0;} break;					//Set arm owner to POV (or unset)
	case POV_1_DOWN: 		if(pressed) {armOwner=1;} else {armOwner=0;} break;					//Set arm owner to POV (or unset)
	case BUTTON_ID(1, 7):	if(pressed) {motor[LiftArm] = -100;} else {motor[LiftArm] = 0;} break; //Lower lift arm
	case BUTTON_ID(1, 5):	if(pressed) {motor[LiftArm] = 100;} else {motor[LiftArm] = 0;} break; //Raise
	case BUTTON_ID(2, 8):	if(pressed) {motor[LiftArm] = -100;} else {motor[LiftArm] = 0;} break; //Lower lift arm
	case BUTTON_ID(2, 6):	if(pressed) {motor[LiftArm] = 100;} else {motor[LiftArm] = 0;} break; //Raise
	case BUTTON_ID(1, 1):	if(pressed) {slowMode=!slowMode;} else {} break; 					//Toggle slow mode
	case BUTTON_ID(1, 2):	if(pressed) {wiggle=true;} else {wiggle=false;} break; 				//Activate wiggle
	}
}

void processEvents() {
	for(short i=1;i<=36;i++) {
		bool pressed = buttonPressed(i);
		if (lastButtons[i] != pressed) {performButtonAction(i, pressed);} //If changed, perform pressed or released action
		lastButtons[i] = pressed;
	}
	return;
}

void initializeRobot() {
	servo[Clamp] = CLAMP_RELEASE;
	return;
}

task main()
{
	initializeRobot();
	waitForStart();   // wait for start of tele-op phase
	int armTarget = 0;
	int armSpeed = 0;
	while (true) {

		processEvents();

		if (wiggle) {
			if (time1[T3] % 400 >= 200) {
				driveSpeedLeft=100;
				driveSpeedRight=0;
			} else {
				driveSpeedLeft=0;
				driveSpeedRight=100;
			}
		} else {
			int maxSpd = (slowMode ? SLOWMO_DRIVE_SPEED : DRIVE_SPEED);
			driveSpeedLeft =  powscl(joystick.joy1_y1, maxSpd);  //Drive as normal taking slow-mode into account
			driveSpeedRight = powscl(joystick.joy1_y2, maxSpd);
		}

		motor[LeftDrive] = driveSpeedLeft;	//Apply drive powers
		motor[RightDrive] = driveSpeedRight;

		int oldArmSpeed=armSpeed;
		armSpeed = -1*powscl(
			((armOwner==0) ? joystick.joy2_y2 : POVAsJoystickY(joystick.joy1_TopHat)),  //R2J2-Y or R1POV-Y
			ARM_SPEED);

		// Position Regulator
		if (armSpeed==0) {
			int armPower;
			if (armSpeed != oldArmSpeed) armTarget=nMotorEncoder[BlockArm]+(sgn(oldArmSpeed)*200); //Set current pos + approx error
			if (armTarget < -300) { // Only correct if above 90 degrees, roughly
				int error = armTarget - nMotorEncoder[BlockArm];
				armPower = coerce((int)(0.1*error), -20, 20);
			} else {
				armPower=0;
			}
			nxtDisplayTextLine(3, "%i", armTarget);

			motor[BlockArm] = armPower;
		} else {
			motor[BlockArm] = armSpeed;
		}
		wait1Msec(5);
	}
}
