#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     MUX,            sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     FRDrive,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     FLDrive,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     BLDrive,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     BRDrive,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     LeftLift,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     BlockArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     RightLift,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    GyroServo,            tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    LeftClamp,            tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    RightClamp,           tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define infared             msensor_S4_1
#define distanceLeft        msensor_S4_2
#define distanceRight       msensor_S4_3
#define lightSensor         msensor_S4_4


bool clampState = true;
long armState = 0;
int gAngle = 0;
int rampStage = 0;
bool fallbackMode=false;

#include "libs/autonomousutils.h"
#include "libs/keyrepeater.h"
#include "autonomousmenus.h"
#include "rampfinder.h"


#define DRV_RANGE   15 //Acceptable movement range
#define GYRO_RANGE  2  //Acceptable turning range

#define RAW_MODE      0
#define DRIVE_INCHES  1
#define TURN_DEGREES  2
#define GYRO_DEGREES  3
#define RAISE_ARM     4
#define LOWER_ARM     5
#define ELEVATE_ARM   6
#define OPEN_CLAMP    7
#define CLOSE_CLAMP   8
#define PAUSE         9
#define BRAKE         10
#define DRIVE_UP_RAMP 11
#define ARC_DEGREES   12
#define ARC_GYRO_DEGREES 13
#define SCOUT_RAMP    14
#define INTERNAL_RAMP 100

#define SCOUT_LEFT 0
#define SCOUT_RIGHT 1

int mode = -1;
int maxTime = 0;
long leftTarget = 0;
long rightTarget = 0;
unsigned int leftSpeed = 100;
unsigned int rightSpeed = 100;
bool completed = true;

void runTargets() {
	if (DEBUG) nxtDisplayCenteredTextLine(6, "%i", nMotorEncoder[FLDrive]); //Debug
	if (DEBUG) nxtDisplayCenteredTextLine(7, "%i", nMotorEncoder[FRDrive]);

	if (mode == RAW_MODE) {
		long leftPos = nMotorEncoder[FLDrive];
		long rightPos = nMotorEncoder[FRDrive];
		if ((inRange(leftPos, leftTarget-DRV_RANGE, leftTarget+DRV_RANGE) &&
			inRange(rightPos, rightTarget-DRV_RANGE, rightTarget+DRV_RANGE)) ||
			time1[T2] > maxTime) {
			completed=true;
		} else {
			int leftPow = getTargetingPower(leftTarget, leftPos, 7.0/leftSpeed, leftSpeed);
			int rightPow = getTargetingPower(rightTarget, rightPos, 7.0/rightSpeed, rightSpeed);
			motor[FLDrive] = leftPow; motor[FRDrive] = rightPow; motor[BLDrive] = leftPow; motor[BRDrive] = rightPow;
		}
	} else if (mode == GYRO_DEGREES) {
		if (inRange(gAngle, leftTarget-GYRO_RANGE, leftTarget+GYRO_RANGE) ||
			time1[T2] > maxTime) {
			completed=true;
		} else {
			int turnPower = getTargetingPower(leftTarget, gAngle, 1, AUTON_TURN_SPEED);
			motor[FLDrive] = turnPower; motor[FRDrive] = -turnPower;
			motor[BLDrive] = turnPower; motor[BRDrive] = -turnPower;
		}
	} else if (mode == ARC_GYRO_DEGREES) {
		if (inRange(gAngle, leftTarget-GYRO_RANGE, leftTarget+GYRO_RANGE) ||
			time1[T2] > maxTime) {
			completed=true;
		} else {
			int turnPower = getTargetingPower(leftTarget, gAngle, 1.8, 100);
			if (leftSpeed>0) {
				int idlePower = getTargetingPower(0, nMotorEncoder[FRDrive], 7.0/50, 50);
				motor[FLDrive] = turnPower*leftSpeed; motor[FRDrive] = idlePower;
				motor[BLDrive] = turnPower*leftSpeed; motor[BRDrive] = idlePower;
			} else {
				int idlePower = getTargetingPower(0, nMotorEncoder[FLDrive], 7.0/50, 50);
				motor[FLDrive] = idlePower; motor[FRDrive] = -turnPower*rightSpeed; //negative
				motor[BLDrive] = idlePower; motor[BRDrive] = -turnPower*rightSpeed; //negative
			}
		}
	} else if (mode == RAISE_ARM || mode == LOWER_ARM || mode == ELEVATE_ARM) {
		// Actual movement is handled in loop
		if (inRange(nMotorEncoder[BlockArm], armState-50, armState+50) ||
			time1[T2] > maxTime) {
			completed=true;
		}
	} else if (mode == OPEN_CLAMP || mode == CLOSE_CLAMP) {
		setClamp(clampState);
		completed=true;
	} else if (mode == PAUSE) {
		if (time1[T2] > maxTime) completed=true;
	} else if (mode == INTERNAL_RAMP) {
		int speed=0;
		//Ramp is ~8 degrees
		if (rampStage==0) { //get on ramp
			if (gAngle<-5) {
				rampStage=1;
				//PlayImmediateTone(440, 10);
			} else {
				speed = -70;
			}
		} else if (rampStage>=1) {
			speed = gAngle*6/(rampStage);
			if (gAngle>=-2 && gAngle<=2) rampStage++; //PlayImmediateTone(444, 10);
			if (rampStage>=4) {
				completed=true;
			} else {
				wait1Msec(rampStage*50);
			}
		}

		motor[FLDrive] = speed; motor[FRDrive] = speed; motor[BLDrive] = speed; motor[BRDrive] = speed;
	} else {
		completed=true;
	}

	if (completed) resetDrive(); // Reset encoders to 0
	return;
}

void setTarget(int modeIn, int maxTimeIn, long leftTargetIn, long rightTargetIn, unsigned int leftSpeedIn, unsigned int rightSpeedIn) {
	// Note: If you're moving less than 1000 counts, set a lower speed than 100

	mode = modeIn; // Define global mode
	maxTime = maxTimeIn; //All modes accept maxTime

	leftSpeed = leftSpeedIn; // These are unused in most instances but set them anyway
	rightSpeed = rightSpeedIn;

	completed = false; // Tell loop to reset whatever neccesary

	if (!gyroEnabled() && mode==GYRO_DEGREES) mode=TURN_DEGREES; // If gyro is disabled switch to a raw turn
	if (!gyroEnabled() && mode==ARC_GYRO_DEGREES) mode=ARC_DEGREES; //ditto

	if (mode==RAW_MODE) {
		leftTarget = leftTargetIn;
		rightTarget = rightTargetIn;
	} else if (mode==DRIVE_INCHES) {
		leftTarget = leftTargetIn*INCH;     //Set position times inch constant
		rightTarget = rightTargetIn*INCH;
		mode = RAW_MODE;                    // Inches have been converted; treat as raw
	} else if (mode==TURN_DEGREES) {
		rightTarget = leftTargetIn*DEGREES;  // Also define approx motor counts incase fallback is needed
		leftTarget = rightTarget*-1;        // Negative power for other side
		leftSpeed = AUTON_TURN_SPEED;
		rightSpeed = AUTON_TURN_SPEED;
		mode = RAW_MODE;                    // Degrees have been converted; treat as raw
	} else if (mode==GYRO_DEGREES) {
		setGyroPos(false);
		resetGyro();gAngle=0;
		leftTarget = leftTargetIn;          // Assign degrees for gyro
	} else if (mode==RAISE_ARM) {
		armState = ARM_RAISED;               // Set arm position
	} else if (mode==LOWER_ARM) {
		armState = -100;
	} else if (mode==ELEVATE_ARM) {
		armState = ARM_ELEVATED;
	} else if (mode==OPEN_CLAMP) {
		clampState = false;         // Set clamp position
	} else if (mode==CLOSE_CLAMP) {
		clampState = true;
	} else if (mode==DRIVE_UP_RAMP) {
		int sel = selection[RAMP_MENU];
		if (sel==0 && gyroEnabled()) {  //Drive until level
			setGyroPos(true); // Run gyro-setting routine
			mode=INTERNAL_RAMP;
		} else {  //Time-based ramp
			leftTarget=-10000;
			rightTarget=-10000; //Unattainably far position for max power
			leftSpeed=100;
			rightSpeed=100;
			mode=RAW_MODE;
			switch(sel) {
				case 1: maxTime=1600; break; //Drive to hump
				case 2: maxTime=1300; break; //Drive to front
				case 3: maxTime=2000; break; //Drive to back
			}
		}
	} else if (mode==ARC_DEGREES) {
		mode = RAW_MODE;
		leftSpeed=100;
		rightSpeed=100;
		if (leftTargetIn != 0) {
			leftTarget=leftTargetIn*DEGREES_ARC;
			rightTarget=0;
		} else { // Right
			leftTarget=0;
			rightTarget=-rightTargetIn*DEGREES_ARC; //note the negative
		}
	} else if (mode==ARC_GYRO_DEGREES) {
		setGyroPos(false);
		resetGyro();
		if (leftTargetIn != 0) {
			leftSpeed=1;
			rightSpeed=0;
			leftTarget = leftTargetIn;
		} else { // Right
			leftSpeed=0;
			rightSpeed=1;
			leftTarget = rightTargetIn;
		}
	} else if (mode==SCOUT_RAMP) {
		// setTarget(SCOUT_RAMP, SCOUT_LEFT or SCOUT_RIGHT, distance behind ramp edge, 0,0,0)
		bool dir = (maxTime==SCOUT_RIGHT);

		int distTo1 = 2400;
		int distTo2 = 5000;

		int sel = selection[SONAR_MENU];
		if (fallbackMode==true) sel=3;

		if (sel==0) {
			findClearRamp((dir ? distanceRight : distanceLeft), leftTargetIn+distTo2);
		} else if (sel==1) {
			findLine(leftTargetIn+distTo2, 1);
		} else if (sel==2) {
			findLine(leftTargetIn+distTo2, 2);
		} else if (sel==3) { //Fallback mode
			mode=RAW_MODE;
			maxTime=3000;
			leftTarget =  -3200;
			rightTarget = -3200;
			leftSpeed = 100;
			rightSpeed = 100;
		}
	}

	time1[T2]=0; // Start clock
	return;
}

void initializeRobot() {
	bDisplayDiagnostics=false;
	setGyroPos(false);
	if (HTSMUXreadPowerStatus(MUX)) {			// Multiplexer is off or dead?
		nxtDisplayBigStringAt(0,45,"   MUX   ");
		nxtDisplayBigStringAt(0,25,"Dead Batt");
		PlayImmediateTone(440, 50);
        wait1Msec(1500);
        eraseDisplay();
        fallbackMode=true;
        selection[SONAR_MENU]=3;
	}
	if (SensorRaw[gyro]>=640 || SensorRaw[gyro]<=590) {		// Gyro moving or disconnected
		nxtDisplayBigStringAt(21,45,"Gyro");
		nxtDisplayBigStringAt(15,25,"Error");
		nxtDisplayCenteredTextLine(7, "%i", SensorRaw[gyro]);
		PlayImmediateTone(440, 50);
		wait1Msec(1500);
		setGyroEnabled(false);
	} else {
		wait1Msec(100);
		nxtDisplayBigStringAt(15,45,"Wait...");
		HTGYROstartCal(gyro);
		PlaySound(soundBeepBeep);
		setGyroEnabled(true);
	}
	eraseDisplay();
	setClamp(true);
	initMenus();
	return;
}

task gyroTask() {
	while (true) {
		gAngle = -1 * gyroAngle();
		if (DEBUG) nxtDisplayCenteredTextLine(5, "%i", gAngle);
	}
}

int pastInc=0;
int currentInc=0;
int pastRoutine=0;
int currentRoutine=0;
bool done=false;
#define CORNER_ROUTINE 0
#define LEFT_OF_RAMP_ROUTINE 1
#define RIGHT_OF_RAMP_ROUTINE 2
#define DUMP_ROUTINE 3

void changeRoutine(int newRoutine) {
	pastRoutine=currentRoutine;
	pastInc=currentInc;
	currentRoutine=newRoutine;
	currentInc=-1;
}

void revertRoutine() {
	currentRoutine=pastRoutine;
	currentInc=pastInc;
}

// ROUTINES

bool corner_d1=false;
bool corner_d2=false;
void cornerRoutine(int increment) {

	if (increment==0) {setTarget(RAW_MODE, 2200, -3400,-3400, 95,95); return;} //Approach Buckets 3400
	if (increment==1) {
		corner_d1 = decideLR(1, corner_d1, selection[BUCKET_MENU], infared); // Make IR or menu decision
		if (corner_d1 == LEFT_DECISION) {
			setTarget(ARC_GYRO_DEGREES, 1400, -20,0, 0,0); //Swing outward left
		} else { //Right
			setTarget(ARC_GYRO_DEGREES, 1400, 0,20, 0,0); //Swing outward right
		}
		return;
	}
	if (increment==2) {
		corner_d2 = decideLR(2, corner_d1, selection[BUCKET_MENU], infared); // Make 2nd IR or menu decision
		if (corner_d2 == DUMP_DECISION) {
			changeRoutine(DUMP_ROUTINE);
		}
		return;
	}
	if (corner_d1 == LEFT_DECISION) {
		switch (increment) {
			case 3: setTarget(GYRO_DEGREES,1100,-30,0,0,0); return; //Continue turning away
			case 4: setTarget(RAW_MODE, 1000, -610,-610, 60,60); return; //Drive closer...
		}
	} else { //Right
		switch (increment) {
			case 3: setTarget(GYRO_DEGREES,1100,30,0,0,0); return; //Continue turning away
			case 4: setTarget(RAW_MODE, 1000, -610,-610, 60,60); return; //Drive closer...
		}
	}
	if (increment==5) {
		if (corner_d2 == WAIT_DECISION) {
			//If we were waiting to dump, dump now
			changeRoutine(DUMP_ROUTINE);
		}
	}
	if (corner_d1 == LEFT_DECISION) {
		switch (increment) {
			case 6: setTarget(GYRO_DEGREES, 2000, -40,0,0,0); return; //Finish turn
			case 7: setTarget(RAW_MODE, 2700, -2700,-2700, 95,95); return; //Drive past buckets
			case 8: setTarget(ARC_GYRO_DEGREES, 2500, 0,90,0,0); return; //Turn
			//case 9: setTarget(RAW_MODE, 2700, -3000,-3000, 95,95); return; //Drive past ramps
			case 9: setTarget(SCOUT_RAMP, SCOUT_LEFT, 600, 0,0,0); return;
			case 10: setTarget(GYRO_DEGREES, 2500, 90,0,0,0); return; //Turn toward ramp
			case 11: setTarget(DRIVE_UP_RAMP,0,0,0,0,0); return;
		}
	} else { //Right
		switch (increment) {
			case 6: setTarget(GYRO_DEGREES, 2000, 40,0,0,0); return; //Finish turn
			case 7: setTarget(RAW_MODE, 2700, -2700,-2700, 95,95); return; //Drive past buckets
			case 8: setTarget(ARC_GYRO_DEGREES, 2500, -90,0,0,0); return; //Turn
			//case 9: setTarget(RAW_MODE, 2700, -3000,-3000, 95,95); return; //Drive past ramps
			case 9: setTarget(SCOUT_RAMP, SCOUT_RIGHT, 600, 0,0,0); return;
			case 10: setTarget(GYRO_DEGREES, 2500, -90,0,0,0); return; //Turn toward ramp
			case 11: setTarget(DRIVE_UP_RAMP,0,0,0,0,0); return;
		}
	}
	if (increment==12) done=true;
}

void leftOfRampRoutine(int increment) {
	switch (increment) {
		case 0: setTarget(RAW_MODE, 1500, -1200,-1200, 60,60); break; //Approach Buckets
		case 1: changeRoutine(DUMP_ROUTINE); break; //Dump
		case 2: setTarget(GYRO_DEGREES, 3000, 90,0, 0,0); break; //Turn left toward ramp
		//case 3: setTarget(RAW_MODE, 2000, -2400,-2400, 90,90); break; //Approach Ramp
		case 3: setTarget(SCOUT_RAMP, SCOUT_RIGHT, 0, 0,0,0); break; //Approach Ramp
		case 4: setTarget(GYRO_DEGREES, 3000, -90,0, 0,0); break; //Turn right; line up toward ramp
		case 5: setTarget(DRIVE_UP_RAMP, 0,0,0,0,0); break; //Drive up ramp
	}
	//done=true;
}

void rightOfRampRoutine(int increment) {
	switch (increment) {
		case 0: setTarget(RAW_MODE, 1500, -1200,-1200, 60,60); break; //Approach Buckets
		case 1: changeRoutine(DUMP_ROUTINE); break; //Dump
		case 2: setTarget(GYRO_DEGREES, 3000, -90,0, 0,0); break; //Turn right toward ramp
		//case 3: setTarget(RAW_MODE, 2000, -2400,-2400, 90,90); break; //Approach Ramp
		case 3: setTarget(SCOUT_RAMP, SCOUT_LEFT, 0, 0,0,0); break; //Approach Ramp
		case 4: setTarget(GYRO_DEGREES, 3000, 90,0, 0,0); break; //Turn left; line up toward ramp
		case 5: setTarget(DRIVE_UP_RAMP, 0,0,0,0,0); break; //Drive up ramp
	}
	//done=true;
}

void dumpRoutine(int increment) {
	switch (increment) {
		case 0: setTarget(RAISE_ARM, 2000, 0,0, 0,0); break; //Raise arm
		case 1: setTarget(PAUSE, 800, 0,0, 0,0); break; //Sleep for .8sec
		case 2: setTarget(OPEN_CLAMP, 0, 0,0, 0,0); break; //Open Clamp
		case 3: setTarget(PAUSE, 400, 0,0, 0,0); break; //Sleep for .4sec
		case 4: setTarget(CLOSE_CLAMP, 0, 0,0, 0,0); break; //Close Clamp
		case 5: setTarget(PAUSE, 400, 0,0, 0,0); break; //Sleep for .4sec then revert routine
		case 6: setTarget(LOWER_ARM, 500, 0,0, 0,0); revertRoutine(); break; //Lower arm and continue
	}
}

void initRoutine() {
	if (currentRoutine == CORNER_ROUTINE) {
		cornerRoutine(currentInc);
	} else if (currentRoutine == LEFT_OF_RAMP_ROUTINE) {
		leftOfRampRoutine(currentInc);
	} else if (currentRoutine == RIGHT_OF_RAMP_ROUTINE) {
		rightOfRampRoutine(currentInc);
	} else if (currentRoutine == DUMP_ROUTINE) {
		dumpRoutine(currentInc);
	}
}
// END ROUTINES

task main() {
	initializeRobot();
	bool programRunning = false;
	while (true) {
		wait1Msec(5);
		if (programStarted() && !programRunning) {   // I.E. program JUST started
			wait1Msec(selection[DELAY_MENU]*1000);   // Wait for selected delay
			currentRoutine=selection[STARTPOS_MENU]; // Set routine
			if (gyroEnabled()) StartTask(gyroTask);  // Start gyro tracking
			resetGyro();          // Set gyro to 0
			resetDrive();         // Set encoders to 0
			programRunning=true;  // Set the running veriable so this doesn't execute again
		}

		if (programStarted()) {
if (DEBUG) nxtDisplayCenteredTextLine(4, "%i", currentRoutine);
			//Constantly update arm movements
			if (armState != 0) motor[BlockArm] = getTargetingPower(armState, nMotorEncoder[BlockArm], 0.04, 80);

			if (currentInc < 100 && !done) { // make sure step never wraps
				if (completed) {
					//Start sequences
					initRoutine(); currentInc++; // Increment step, make sure it doesn't ever wrap
				}
				runTargets();
			}
		} else {
			processMenuInput();
		}
	}
}
