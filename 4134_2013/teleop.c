#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     MUX,            sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     FRDrive,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     FLDrive,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     BLDrive,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     BRDrive,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     LeftLift,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     BlockArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     RightLift,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_4,    GyroServo,            tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    LeftClamp,            tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    RightClamp,           tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "libs/teleoputils.h"

#define infared             msensor_S4_1
#define ultrasonicLeft      msensor_S4_2
#define ultrasonicRight     msensor_S4_3
#define lightSensor         msensor_S4_4

bool lastButtons[37];
int armOwner=0;  //1: Rem1POV, 0: Rem2J2 ; Changed dynamically as needed
bool wiggle=false;
bool slowMode=false;
int driveSpeedLeft;
int driveSpeedRight;


bool endGameUnlocked = false;

void setLiftPwr(int pwr) {
	motor[LeftLift]=pwr;
	motor[RightLift]=pwr;
}

void performButtonAction(short buttonID, bool pressed) {
	switch(buttonID) {
	case BUTTON_ID(1, 6): 	if(pressed && endGameUnlocked) {motor[Flag] = 100;} else {motor[Flag] = 0;} break;	//Flag
	case BUTTON_ID(1, 8): 	if(pressed && endGameUnlocked) {motor[Flag] = -100;} else {motor[Flag] = 0;} break;	//Flag
	case BUTTON_ID(1, 4):	if(pressed) {endGameUnlocked=true;} break;							//Cancel endgame lock
	case POV_1_LEFT: 		if(pressed) {setClamp(false);} break;								//Release Clamp
	case POV_1_RIGHT: 		if(pressed) {setClamp(true);} break;								//Hold Clamp
	case BUTTON_ID(2, 5): 	if(pressed) {setClamp(false);} break;								//Release Clamp
	case BUTTON_ID(2, 7): 	if(pressed) {setClamp(true);} break;								//Hold Clamp
	case POV_1_UP:	 		if(pressed) {armOwner=1;} else {armOwner=0;} break;					//Set arm owner to POV (or unset)
	case POV_1_DOWN: 		if(pressed) {armOwner=1;} else {armOwner=0;} break;					//Set arm owner to POV (or unset)
	case BUTTON_ID(1, 5):	if(pressed) {setLiftPwr(-100);} else {setLiftPwr(0);} break; 		//Lower lift arm
	case BUTTON_ID(1, 7):	if(pressed) {setLiftPwr(100);} else {setLiftPwr(0);} break; 		//Raise
	case BUTTON_ID(2, 6):	if(pressed) {setLiftPwr(-100);} else {setLiftPwr(0);} break; 		//Lower lift arm
	case BUTTON_ID(2, 8):	if(pressed) {setLiftPwr(100);} else {setLiftPwr(0);} break; 		//Raise
	case BUTTON_ID(1, 1):	if(pressed) {slowMode=!slowMode;} else {} break; 					//Toggle slow mode
	case BUTTON_ID(1, 2):	if(pressed) {wiggle=true;} else {wiggle=false;} break; 				//Activate wiggle
	}
}

void processEvents() {
	for(short i=1;i<=36;i++) {
		bool pressed = buttonPressed(i);
		if (lastButtons[i] != pressed) {performButtonAction(i, pressed);} //If changed, perform pressed or released action
		lastButtons[i] = pressed;
	}
	return;
}

void initializeRobot() {
	servo[LeftClamp] = CLAMP_LEFT_RELEASE;
	servo[RightClamp] = CLAMP_RIGHT_RELEASE;
	servo[GyroServo] = GYRO_SERVO_VERT;
	return;
}

task main() {
	initializeRobot();
	waitForStart();   // wait for start of tele-op phase
	int armTarget = 0;
	int armSpeed = 0;
	time1[T2]=0; //T2 - Time since start
	while (true) {

		processEvents();

		if (time1[T2] > 89000) endGameUnlocked=true;

		if (wiggle) {
			if (time1[T3] % 400 >= 200) {
				driveSpeedLeft=100;
				driveSpeedRight=0;
			} else {
				driveSpeedLeft=0;
				driveSpeedRight=100;
			}
		} else {
			int maxSpd = (slowMode ? SLOWMO_DRIVE_SPEED : DRIVE_SPEED);
			driveSpeedLeft =  remoteToMotor(joystick.joy1_y1, maxSpd);  //Drive as normal taking slow-mode into account
			driveSpeedRight = remoteToMotor(joystick.joy1_y2, maxSpd);
		}

		motor[FLDrive] = driveSpeedLeft;	//Apply drive powers
		motor[FRDrive] = driveSpeedRight;
		motor[BLDrive] = driveSpeedLeft;
		motor[BRDrive] = driveSpeedRight;


		int oldArmSpeed=armSpeed;
		armSpeed = -1*remoteToMotor(
			((armOwner==0) ? joystick.joy2_y2 : POVAsJoystickY(joystick.joy1_TopHat)),  //R2J2-Y or R1POV-Y
			ARM_SPEED);

		// Position Regulator
		if (armSpeed==0) {
			int armPower;
			if (armSpeed != oldArmSpeed) armTarget=nMotorEncoder[BlockArm]+(sgn(oldArmSpeed)*300); //If *just* stopped, set current pos + approx overshoot
			if (armTarget < ARM_DROP_ZONE) { // Only correct if above 90 degrees, roughly
				armPower = getTargetingPower(armTarget, nMotorEncoder[BlockArm], 0.1, 20);
			} else {
				armPower=0;
			}

			motor[BlockArm] = armPower;
		} else {
			motor[BlockArm] = armSpeed;
		}
		wait1Msec(5);
	}
}
